1.synchronized和volatile的区别？
	1).volatile关键字解决的是变量在多线程之间的可见性；synchronized关键字解决的是
	   多线程之间访问共享资源的同步性。
	2).volatile只能用于修饰变量，而synchronized可以修饰方法，以及代码块。
	3).volatile是线程同步的轻量级实现，所以性能比synchronized要好。
	4).多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。
	5).volatile能保证变量在多线程之间的可见性，但不能保证原子性；而synchronized可以
	   保证原子性，也可以间接保证可见性，因为它会将私有内存和共有内存中的数据做同步。

线程安全包含原子性和可见性两个方面。
对于用volatile修饰的变量，JVM虚拟机只是保证从主内存加载到线程工作内存的值是最新的。
一句话说明volatile的作用：实现变量在多个线程之间的可见性。

2.synchronized和lock区别？
	1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
	2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
	   而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，
	   因此使用Lock时需要在finally块中释放锁；
	3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等
	   待的线程会一直等待下去，不能够响应中断；
	4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
	5）Lock可以提高多个线程进行读操作的效率（读写锁）。
　　	   在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时
          （即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使
	   用时要根据适当情况选择。

3.synchronized在jdk1.6之后做了什么改进？
	1.适应自旋锁 自旋锁：为了减少线程状态改变带来的消耗 不停地执行当前线程 
	2.锁消除：不可能存在共享数据竞争的锁进行消除
	3.锁粗化：将连续的加锁 精简到只加一次锁
	4.轻量级锁：无竞争条件下 通过CAS消除同步互斥
	5.偏向锁：无竞争条件下 消除整个同步互斥，连CAS都不操作。
4.CAS是什么？java中有什么应用？
	从字面上理解就是比较并更新，简单来说：从某一内存上取值V，和预期值A进行比较，如果内存
	值V和预期值A的结果相等，那么我们就把新值B更新到内存，如果不相等，那么就重复上述操作直到成功为止。
	它可以解决多线程并发安全的问题。
5.虚拟机栈为什么会内存溢出？
	如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟
	机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。


	